{"ast":null,"code":"import { createClient } from '@supabase/supabase-js';\nconst supabaseUrl = 'https://ptmpshcuvhshcwbpaqit.supabase.co';\nconst supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB0bXBzaGN1dmhzaGN3YnBhcWl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1ODExNDIsImV4cCI6MjA3NDE1NzE0Mn0.Nrt89ux7TWCwPojWDgtDk3wXbeyT51ruMjmuzcvnlCY';\nexport const supabase = createClient(supabaseUrl, supabaseKey);\n\n// Product data types\n\n// Category management types\n\n// Get categories with product counts from the categories table\nexport const getCategoriesWithCounts = async () => {\n  try {\n    console.log('Fetching categories with counts from Supabase...');\n\n    // First, get all categories\n    const {\n      data: categories,\n      error: categoriesError\n    } = await supabase.from('categories').select('*').order('sort_order');\n    if (categoriesError) {\n      console.error('Categories error:', categoriesError);\n      throw categoriesError;\n    }\n\n    // Then get product counts for each category\n    const categoriesWithCounts = await Promise.all((categories || []).map(async category => {\n      const {\n        count,\n        error: countError\n      } = await supabase.from('product_data').select('*', {\n        count: 'exact',\n        head: true\n      }).eq('product_type', category.category_key);\n      if (countError) {\n        console.warn(`Error counting products for ${category.category_key}:`, countError);\n      }\n      return {\n        ...category,\n        product_count: count || 0\n      };\n    }));\n    console.log('Categories with counts received:', categoriesWithCounts === null || categoriesWithCounts === void 0 ? void 0 : categoriesWithCounts.length, 'items');\n    return categoriesWithCounts || [];\n  } catch (error) {\n    console.error('Error fetching categories with counts:', error);\n    return [];\n  }\n};\n\n// Legacy function for backwards compatibility\nexport const getProductCategories = async () => {\n  const categories = await getCategoriesWithCounts();\n  return categories.map(cat => ({\n    name: cat.category_key,\n    productCount: cat.product_count\n  }));\n};\n\n// Update category image\nexport const updateCategoryImage = async (categoryKey, imageUrl) => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.rpc('update_category_image', {\n      p_category_key: categoryKey,\n      p_image_url: imageUrl\n    });\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Error updating category image:', error);\n    return false;\n  }\n};\n\n// Toggle category status\nexport const toggleCategoryStatus = async categoryKey => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.rpc('toggle_category_status', {\n      p_category_key: categoryKey\n    });\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Error toggling category status:', error);\n    return false;\n  }\n};\n\n// Update category details\nexport const updateCategory = async (id, updates) => {\n  try {\n    const {\n      error\n    } = await supabase.from('categories').update({\n      ...updates,\n      updated_at: new Date().toISOString()\n    }).eq('id', id);\n    if (error) throw error;\n    return true;\n  } catch (error) {\n    console.error('Error updating category:', error);\n    return false;\n  }\n};\n\n// Get active categories only\nexport const getActiveCategories = async () => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('categories').select('*').eq('is_active', true).order('sort_order');\n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error fetching active categories:', error);\n    return [];\n  }\n};\n\n// Get products by category\nexport const getProductsByCategory = async category => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('product_data').select('*').eq('product_type', category).limit(50);\n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error fetching products:', error);\n    return [];\n  }\n};\n\n// Color variant information\n\n// Grouped product type - represents a product with all its variants\n\n// Group products by style_code only (combining all color and size variants)\nexport const groupProductVariants = products => {\n  const grouped = new Map();\n  products.forEach(product => {\n    // Group only by style_code to combine all color/size variants\n    const key = product.style_code;\n    if (!grouped.has(key)) {\n      // Create new grouped product entry\n      const price = parseFloat(product.single_price) || 0;\n      grouped.set(key, {\n        style_code: product.style_code,\n        style_name: product.style_name,\n        brand: product.brand,\n        product_type: product.product_type,\n        primary_product_image_url: product.primary_product_image_url,\n        gender: product.gender,\n        categorisation: product.categorisation,\n        age_group: product.age_group,\n        accreditations: product.accreditations,\n        sustainable_organic: product.sustainable_organic,\n        specification: product.specification,\n        retail_description: product.retail_description,\n        fabric: product.fabric,\n        variants: [product],\n        colors: [{\n          colour_code: product.colour_code,\n          colour_name: product.colour_name,\n          colour_image: product.colour_image,\n          rgb: product.rgb,\n          colour_shade: product.colour_shade\n        }],\n        sizes: [product.size_name],\n        size_range: product.size_range,\n        price_range: {\n          min: price,\n          max: price\n        }\n      });\n    } else {\n      // Add variant to existing group\n      const group = grouped.get(key);\n      group.variants.push(product);\n\n      // Add color if not already present\n      const colorExists = group.colors.some(c => c.colour_code === product.colour_code);\n      if (!colorExists) {\n        group.colors.push({\n          colour_code: product.colour_code,\n          colour_name: product.colour_name,\n          colour_image: product.colour_image,\n          rgb: product.rgb,\n          colour_shade: product.colour_shade\n        });\n      }\n\n      // Add size if not already present\n      if (!group.sizes.includes(product.size_name)) {\n        group.sizes.push(product.size_name);\n      }\n\n      // Update price range\n      const price = parseFloat(product.single_price) || 0;\n      group.price_range.min = Math.min(group.price_range.min, price);\n      group.price_range.max = Math.max(group.price_range.max, price);\n    }\n  });\n  return Array.from(grouped.values());\n};\n\n// Fetch and group products for carousel\nexport const getGroupedProductsForCarousel = async (limit = 12) => {\n  try {\n    // Fetch a large sample to ensure we get enough unique style codes\n    // Since products have multiple variants (colors/sizes), we need many rows\n    const {\n      data,\n      error\n    } = await supabase.from('product_data').select('*').limit(200); // Fetch 200 rows to ensure variety\n\n    if (error) throw error;\n\n    // Group the products by style_code\n    const grouped = groupProductVariants(data || []);\n\n    // Return only the requested number of unique products\n    return grouped.slice(0, limit);\n  } catch (error) {\n    console.error('Error fetching grouped products:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["createClient","supabaseUrl","supabaseKey","supabase","getCategoriesWithCounts","console","log","data","categories","error","categoriesError","from","select","order","categoriesWithCounts","Promise","all","map","category","count","countError","head","eq","category_key","warn","product_count","length","getProductCategories","cat","name","productCount","updateCategoryImage","categoryKey","imageUrl","rpc","p_category_key","p_image_url","toggleCategoryStatus","updateCategory","id","updates","update","updated_at","Date","toISOString","getActiveCategories","getProductsByCategory","limit","groupProductVariants","products","grouped","Map","forEach","product","key","style_code","has","price","parseFloat","single_price","set","style_name","brand","product_type","primary_product_image_url","gender","categorisation","age_group","accreditations","sustainable_organic","specification","retail_description","fabric","variants","colors","colour_code","colour_name","colour_image","rgb","colour_shade","sizes","size_name","size_range","price_range","min","max","group","get","push","colorExists","some","c","includes","Math","Array","values","getGroupedProductsForCarousel","slice"],"sources":["/home/alastair/Desktop/outpost-custom/outpost-custom/src/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = 'https://ptmpshcuvhshcwbpaqit.supabase.co';\r\nconst supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB0bXBzaGN1dmhzaGN3YnBhcWl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg1ODExNDIsImV4cCI6MjA3NDE1NzE0Mn0.Nrt89ux7TWCwPojWDgtDk3wXbeyT51ruMjmuzcvnlCY';\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey);\r\n\r\n// Product data types\r\nexport interface Product {\r\n  id: string;\r\n  sku_code: string;\r\n  style_code: string;\r\n  style_name: string;\r\n  brand: string;\r\n  product_type: string;\r\n  primary_colour: string;\r\n  primary_product_image_url: string;\r\n  single_price: string; // Changed to string since it comes as string from DB\r\n  gender: string;\r\n  categorisation: string;\r\n  colour_code: string;\r\n  colour_name: string;\r\n  colour_image: string;\r\n  size_code: string;\r\n  size_name: string;\r\n  size_range: string;\r\n  rgb: string;\r\n  // Additional fields from the full product data\r\n  fabric?: string;\r\n  colour_shade?: string;\r\n  age_group?: string;\r\n  accreditations?: string;\r\n  sustainable_organic?: string;\r\n  specification?: string;\r\n  retail_description?: string;\r\n}\r\n\r\n// Category management types\r\nexport interface CategoryData {\r\n  id: string;\r\n  category_key: string;\r\n  display_name: string;\r\n  description?: string;\r\n  image_url?: string;\r\n  is_active: boolean;\r\n  sort_order: number;\r\n  category_group: string;\r\n  product_count: number;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\n// Get categories with product counts from the categories table\r\nexport const getCategoriesWithCounts = async (): Promise<CategoryData[]> => {\r\n  try {\r\n    console.log('Fetching categories with counts from Supabase...');\r\n    \r\n    // First, get all categories\r\n    const { data: categories, error: categoriesError } = await supabase\r\n      .from('categories')\r\n      .select('*')\r\n      .order('sort_order');\r\n    \r\n    if (categoriesError) {\r\n      console.error('Categories error:', categoriesError);\r\n      throw categoriesError;\r\n    }\r\n    \r\n    // Then get product counts for each category\r\n    const categoriesWithCounts = await Promise.all(\r\n      (categories || []).map(async (category) => {\r\n        const { count, error: countError } = await supabase\r\n          .from('product_data')\r\n          .select('*', { count: 'exact', head: true })\r\n          .eq('product_type', category.category_key);\r\n        \r\n        if (countError) {\r\n          console.warn(`Error counting products for ${category.category_key}:`, countError);\r\n        }\r\n        \r\n        return {\r\n          ...category,\r\n          product_count: count || 0\r\n        };\r\n      })\r\n    );\r\n    \r\n    console.log('Categories with counts received:', categoriesWithCounts?.length, 'items');\r\n    return categoriesWithCounts || [];\r\n  } catch (error) {\r\n    console.error('Error fetching categories with counts:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Legacy function for backwards compatibility\r\nexport const getProductCategories = async () => {\r\n  const categories = await getCategoriesWithCounts();\r\n  return categories.map(cat => ({\r\n    name: cat.category_key,\r\n    productCount: cat.product_count\r\n  }));\r\n};\r\n\r\n// Update category image\r\nexport const updateCategoryImage = async (categoryKey: string, imageUrl: string): Promise<boolean> => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .rpc('update_category_image', {\r\n        p_category_key: categoryKey,\r\n        p_image_url: imageUrl\r\n      });\r\n    \r\n    if (error) throw error;\r\n    return data;\r\n  } catch (error) {\r\n    console.error('Error updating category image:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Toggle category status\r\nexport const toggleCategoryStatus = async (categoryKey: string): Promise<boolean> => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .rpc('toggle_category_status', {\r\n        p_category_key: categoryKey\r\n      });\r\n    \r\n    if (error) throw error;\r\n    return data;\r\n  } catch (error) {\r\n    console.error('Error toggling category status:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Update category details\r\nexport const updateCategory = async (\r\n  id: string, \r\n  updates: Partial<Pick<CategoryData, 'display_name' | 'description' | 'category_group' | 'sort_order' | 'is_active'>>\r\n): Promise<boolean> => {\r\n  try {\r\n    const { error } = await supabase\r\n      .from('categories')\r\n      .update({ ...updates, updated_at: new Date().toISOString() })\r\n      .eq('id', id);\r\n    \r\n    if (error) throw error;\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error updating category:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// Get active categories only\r\nexport const getActiveCategories = async (): Promise<CategoryData[]> => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('categories')\r\n      .select('*')\r\n      .eq('is_active', true)\r\n      .order('sort_order');\r\n    \r\n    if (error) throw error;\r\n    return data || [];\r\n  } catch (error) {\r\n    console.error('Error fetching active categories:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Get products by category\r\nexport const getProductsByCategory = async (category: string) => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('product_data')\r\n      .select('*')\r\n      .eq('product_type', category)\r\n      .limit(50);\r\n\r\n    if (error) throw error;\r\n    return data || [];\r\n  } catch (error) {\r\n    console.error('Error fetching products:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Color variant information\r\nexport interface ColorVariant {\r\n  colour_code: string;\r\n  colour_name: string;\r\n  colour_image: string;\r\n  rgb: string;\r\n  colour_shade?: string;\r\n}\r\n\r\n// Grouped product type - represents a product with all its variants\r\nexport interface GroupedProduct {\r\n  style_code: string;\r\n  style_name: string;\r\n  brand: string;\r\n  product_type: string;\r\n  primary_product_image_url: string;\r\n  gender: string;\r\n  categorisation: string;\r\n  age_group?: string;\r\n  accreditations?: string;\r\n  sustainable_organic?: string;\r\n  specification?: string;\r\n  retail_description?: string;\r\n  fabric?: string;\r\n  // Aggregated variant data\r\n  variants: Product[];\r\n  colors: ColorVariant[];\r\n  sizes: string[];\r\n  size_range: string;\r\n  price_range: {\r\n    min: number;\r\n    max: number;\r\n  };\r\n}\r\n\r\n// Group products by style_code only (combining all color and size variants)\r\nexport const groupProductVariants = (products: Product[]): GroupedProduct[] => {\r\n  const grouped = new Map<string, GroupedProduct>();\r\n\r\n  products.forEach((product) => {\r\n    // Group only by style_code to combine all color/size variants\r\n    const key = product.style_code;\r\n\r\n    if (!grouped.has(key)) {\r\n      // Create new grouped product entry\r\n      const price = parseFloat(product.single_price) || 0;\r\n      grouped.set(key, {\r\n        style_code: product.style_code,\r\n        style_name: product.style_name,\r\n        brand: product.brand,\r\n        product_type: product.product_type,\r\n        primary_product_image_url: product.primary_product_image_url,\r\n        gender: product.gender,\r\n        categorisation: product.categorisation,\r\n        age_group: product.age_group,\r\n        accreditations: product.accreditations,\r\n        sustainable_organic: product.sustainable_organic,\r\n        specification: product.specification,\r\n        retail_description: product.retail_description,\r\n        fabric: product.fabric,\r\n        variants: [product],\r\n        colors: [{\r\n          colour_code: product.colour_code,\r\n          colour_name: product.colour_name,\r\n          colour_image: product.colour_image,\r\n          rgb: product.rgb,\r\n          colour_shade: product.colour_shade,\r\n        }],\r\n        sizes: [product.size_name],\r\n        size_range: product.size_range,\r\n        price_range: {\r\n          min: price,\r\n          max: price,\r\n        },\r\n      });\r\n    } else {\r\n      // Add variant to existing group\r\n      const group = grouped.get(key)!;\r\n      group.variants.push(product);\r\n\r\n      // Add color if not already present\r\n      const colorExists = group.colors.some(c => c.colour_code === product.colour_code);\r\n      if (!colorExists) {\r\n        group.colors.push({\r\n          colour_code: product.colour_code,\r\n          colour_name: product.colour_name,\r\n          colour_image: product.colour_image,\r\n          rgb: product.rgb,\r\n          colour_shade: product.colour_shade,\r\n        });\r\n      }\r\n\r\n      // Add size if not already present\r\n      if (!group.sizes.includes(product.size_name)) {\r\n        group.sizes.push(product.size_name);\r\n      }\r\n\r\n      // Update price range\r\n      const price = parseFloat(product.single_price) || 0;\r\n      group.price_range.min = Math.min(group.price_range.min, price);\r\n      group.price_range.max = Math.max(group.price_range.max, price);\r\n    }\r\n  });\r\n\r\n  return Array.from(grouped.values());\r\n};\r\n\r\n// Fetch and group products for carousel\r\nexport const getGroupedProductsForCarousel = async (limit: number = 12): Promise<GroupedProduct[]> => {\r\n  try {\r\n    // Fetch a large sample to ensure we get enough unique style codes\r\n    // Since products have multiple variants (colors/sizes), we need many rows\r\n    const { data, error } = await supabase\r\n      .from('product_data')\r\n      .select('*')\r\n      .limit(200); // Fetch 200 rows to ensure variety\r\n\r\n    if (error) throw error;\r\n\r\n    // Group the products by style_code\r\n    const grouped = groupProductVariants(data || []);\r\n\r\n    // Return only the requested number of unique products\r\n    return grouped.slice(0, limit);\r\n  } catch (error) {\r\n    console.error('Error fetching grouped products:', error);\r\n    return [];\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}